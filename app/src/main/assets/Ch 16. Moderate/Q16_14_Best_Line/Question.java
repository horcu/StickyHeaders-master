{"Id":"90638250-4c6f-4776-8dab-9e29dce25911","Topic":"Question.java","Question":"","Solution":"package Q16_14_Best_Line;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Set;\r\n\r\nimport CtCILibrary.HashMapList;\r\n\r\npublic class Question {\t\r\n\t/* Find line that goes through most number of points. */\r\n\tpublic static Line findBestLine(GraphPoint[] points) {\r\n\t\tHashMapList<Double, Line> linesBySlope = getListOfLines(points);\r\n\t\treturn getBestLine(linesBySlope);\r\n\t}\r\n\t\r\n\t/* Add each pair of points as a line to the list. */\r\n\tpublic static HashMapList<Double, Line> getListOfLines(GraphPoint[] points) {\r\n\t\tHashMapList<Double, Line> linesBySlope = new HashMapList<Double, Line>();\r\n\t\tfor (int i = 0; i < points.length; i++) {\r\n\t\t\tfor (int j = i + 1; j < points.length; j++) {\r\n\t\t\t\tLine line = new Line(points[i], points[j]);\r\n\t\t\t\tdouble key = Line.floorToNearestEpsilon(line.slope);\r\n\t\t\t\tlinesBySlope.put(key, line);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn linesBySlope;\r\n\t}\t\t\r\n\t\r\n\t/* Return the line with the most equivalent other lines. */\r\n\tpublic static Line getBestLine(HashMapList<Double, Line> linesBySlope) {\r\n\t\tLine bestLine = null;\r\n\t\tint bestCount = 0;\r\n\t\t\r\n\t\tSet<Double> slopes = linesBySlope.keySet();\r\n\t\t\r\n\t\tfor (double slope : slopes) {\r\n\t\t\tArrayList<Line> lines = linesBySlope.get(slope);\r\n\t\t\tfor (Line line : lines) {\r\n\t\t\t\t/* count lines that are equivalent to current line */\r\n\t\t\t\tint count = countEquivalentLines(linesBySlope, line);\r\n\t\t\t\t\r\n\t\t\t\t/* if better than current line, replace it */\r\n\t\t\t\tif (count > bestCount) {\r\n\t\t\t\t\tbestLine = line;\r\n\t\t\t\t\tbestCount = count;\r\n\t\t\t\t\tbestLine.Print();\r\n\t\t\t\t\tSystem.out.println(bestCount);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} \r\n\t\treturn bestLine;\r\n\t}\r\n\t\r\n\t/* Check hashmap for lines that are equivalent. Note that we need to check one epsilon above and below the actual slope\r\n\t * since we're defining two lines as equivalent if they're within an epsilon of each other.\r\n\t */\r\n\tpublic static int countEquivalentLines(HashMapList<Double, Line> linesBySlope, Line line) {\r\n\t\tdouble key = Line.floorToNearestEpsilon(line.slope);\r\n\t\tint count = countEquivalentLines(linesBySlope.get(key), line);\r\n\t\tcount += countEquivalentLines(linesBySlope.get(key - Line.epsilon), line);\r\n\t\tcount += countEquivalentLines(linesBySlope.get(key + Line.epsilon), line);\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t/* Count lines within an array of lines which are \"equivalent\" (slope and y-intercept are within an epsilon value) to a given line */\r\n\tpublic static int countEquivalentLines(ArrayList<Line> lines, Line line) {\r\n\t\tif (lines == null) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\tint count = 0;\r\n\t\tfor (Line parallelLine : lines) {\r\n\t\t\tif (parallelLine.isEquivalent(line)) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\t\t\r\n\t}\r\n\t\r\n\r\n\t\r\n\tpublic static GraphPoint[] createPoints() {\r\n\t\tint n_points = 100;\r\n\t\tSystem.out.println(\"Points on Graph\\n***************\");\r\n\t\tGraphPoint[] points = new GraphPoint[n_points - 1];\r\n\t\tfor (int i = 0; i < n_points / 2; i++) {\r\n\t\t\tGraphPoint p = new GraphPoint(i, 2.3 * ((double)i) + 20.0);\r\n\t\t\tpoints[i] = p;\r\n\t\t\tSystem.out.println(p.toString());\r\n\t\t}\r\n\t\tfor (int i = 0; i < n_points / 2 - 1; i++) {\r\n\t\t\tGraphPoint p = new GraphPoint(i, 3.0 * ((double)i) + 1.0);\r\n\t\t\tpoints[n_points / 2 + i] = p;\r\n\t\t\tSystem.out.println(p.toString());\r\n\t\t}\r\n\t\tSystem.out.println(\"****************\\n\");\r\n\t\treturn points;\r\n\t}\r\n\t\r\n\tpublic static int validate(Line line, GraphPoint[] points) {\r\n\t\tint count = 0;\r\n\t\tfor (int i = 0; i < points.length; i++) {\r\n\t\t\tfor (int j = i + 1; j < points.length; j++) {\r\n\t\t\t\tLine other = new Line(points[i], points[j]);\r\n\t\t\t\tif (line.isEquivalent(other)) {\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tGraphPoint[] points = createPoints();\r\n\t\tLine line = findBestLine(points);\r\n\t\tline.Print();\r\n\t\tSystem.out.println(validate(line, points));\r\n\t}\r\n}\r\n","Chapter":"Q16_14_Best_Line"}