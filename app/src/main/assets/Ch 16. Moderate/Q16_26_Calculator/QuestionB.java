{"Id":"7c37ad91-1129-4998-872e-24348a166771","Topic":"QuestionB.java","Question":"","Solution":"package Q16_26_Calculator;\nimport java.util.Stack;\n\npublic class QuestionB {\n\tpublic enum Operator {\n\t\tADD, SUBTRACT, MULTIPLY, DIVIDE, BLANK\n\t}\n\t\n\t/* Return the operator that occurs as offset. */\n\tpublic static Operator parseNextOperator(String sequence, int offset) {\n\t\tif (offset < sequence.length()) {\n\t\t\tchar op = sequence.charAt(offset);\n\t\t\tswitch(op) {\n\t\t\tcase '+': return Operator.ADD;\n\t\t\tcase '-': return Operator.SUBTRACT;\n\t\t\tcase '*': return Operator.MULTIPLY;\n\t\t\tcase '/': return Operator.DIVIDE;\n\t\t\t}\n\t\t}\n\t\treturn Operator.BLANK;\n\t}\t\n\t\n\t/* Return the number that starts at offset. */\n\tpublic static int parseNextNumber(String seq, int offset) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (offset < seq.length() && Character.isDigit(seq.charAt(offset))) {\n\t\t\tsb.append(seq.charAt(offset));\n\t\t\toffset++;\n\t\t}\n\t\treturn Integer.parseInt(sb.toString());\t\n\t}\t\n\t\n\t/* Apply operator: left [op] right. */\n\tpublic static double applyOp(double left, Operator op, double right) {\n\t\tif (op == Operator.ADD) {\n\t\t\treturn left + right;\n\t\t} else if (op == Operator.SUBTRACT) {\n\t\t\treturn left - right;\n\t\t} else if (op == Operator.MULTIPLY) {\n\t\t\treturn left * right;\n\t\t} else if (op == Operator.DIVIDE) {\n\t\t\treturn left / right;\n\t\t} else {\n\t\t\treturn right;\n\t\t}\n\t}\n\t\n\t/* Return priority of operator. Mapped so that:\n\t *     addition == subtraction < multiplication == division. */\n\tpublic static int priorityOfOperator(Operator op) {\n\t\tswitch (op) {\n\t\tcase ADD: return 1;\n\t\tcase SUBTRACT: return 1;\n\t\tcase MULTIPLY: return 2;\n\t\tcase DIVIDE: return 2;\n\t\tcase BLANK: return 0;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t/* Collapse top until priority(futureTop) > priority(top). \n\t * Collapsing means to pop the top 2 numbers and apply the \n\t * operator popped from the top of the operator stack, and then\n\t * push that onto the numbers stack.*/\n\tpublic static void collapseTop(Operator futureTop, Stack<Double> numberStack, Stack<Operator> operatorStack) {\n\t\twhile (operatorStack.size() >= 1 && numberStack.size() >= 2) {\n\t\t\tif (priorityOfOperator(futureTop) <= priorityOfOperator(operatorStack.peek())) {\n\t\t\t\tdouble second = numberStack.pop();\n\t\t\t\tdouble first = numberStack.pop();\n\t\t\t\tOperator op = operatorStack.pop();\n\t\t\t\tdouble collapsed = applyOp(first, op, second);\n\t\t\t\tnumberStack.push(collapsed);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static double compute(String sequence) {\n\t\tStack<Double> numberStack = new Stack<Double>();\n\t\tStack<Operator> operatorStack = new Stack<Operator>();\n\t\t\n\t\tfor (int i = 0; i < sequence.length(); i++) {\n\t\t\ttry\n\t\t\t{\n\t\t\t\t/* Get number and push. */\n\t\t\t\tint value = parseNextNumber(sequence, i);\n\t\t\t\tnumberStack.push((double) value);\n\t\t\t\t\n\t\t\t\t/* Move to the operator. */\n\t\t\t\ti += Integer.toString(value).length();\n\t\t\t\tif (i >= sequence.length()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* Get operator, collapse top as needed, push operator. */\n\t\t\t\tOperator op = parseNextOperator(sequence, i);\n\t\t\t\tcollapseTop(op, numberStack, operatorStack);\n\t\t\t\toperatorStack.push(op);\n\t\t\t} catch (NumberFormatException ex) {\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Do final collapse. */\n\t\tcollapseTop(Operator.BLANK, numberStack, operatorStack);\n\t\tif (numberStack.size() == 1 && operatorStack.size() == 0) {\n\t\t\treturn numberStack.pop();\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tString expression = \"6/5*3+4*5/2-12/6*3/3+3+3\";\n\t\tdouble result = compute(expression);\n\t\tSystem.out.println(result);\t\t\n\t}\n\n}\n","Chapter":"Q16_26_Calculator"}