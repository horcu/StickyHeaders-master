{"Id":"ceeabf34-86bc-4806-880f-4592f7814652","Topic":"QuestionB.java","Question":"","Solution":"package Q17_22_Word_Transformer;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedList;\r\nimport java.util.Set;\r\n\r\nimport CtCILibrary.HashMapList;\r\n\r\npublic class QuestionB {\r\n\t\r\n\t/* find path to transform startWord into endWord. */\r\n\tpublic static LinkedList<String> transform(String start, String stop, String[] words) {\r\n\t\tHashMapList<String, String> wildcardToWordList = createWildcardToWordMap(words);\r\n\t\tHashSet<String> visited = new HashSet<String>();\r\n\t\treturn transform(visited, start, stop, wildcardToWordList);\r\n\t}\r\n\t\r\n\t/* Do a depth-first search from start to stop, traveling through each word that is one edit away. */\r\n\tpublic static LinkedList<String> transform(HashSet<String> visited, String start, String stop, HashMapList<String, String> wildcardToWordList) {\r\n\t\tif (start.equals(stop)) {\r\n\t\t\tLinkedList<String> path = new LinkedList<String>();\r\n\t\t\tpath.add(start);\r\n\t\t\treturn path;\r\n\t\t} else if (visited.contains(start)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvisited.add(start);\r\n\t\tArrayList<String> words = getValidLinkedWords(start, wildcardToWordList);\r\n\t\t\r\n\t\tfor (String word : words) {\r\n\t\t\tLinkedList<String> path = transform(visited, word, stop, wildcardToWordList);\r\n\t\t\tif (path != null) {\r\n\t\t\t\tpath.addFirst(start);\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/* Insert words in dictionary into mapping from wildcard form -> word. */\r\n\tpublic static HashMapList<String, String> createWildcardToWordMap(String[] words) {\r\n\t\tHashMapList<String, String> wildcardToWords = new HashMapList<String, String>();\r\n\t\tfor (String word : words) {\r\n\t\t\tArrayList<String> linked = getWildcardRoots(word);\r\n\t\t\tfor (String linkedWord : linked) {\r\n\t\t\t\twildcardToWords.put(linkedWord, word);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn wildcardToWords;\r\n\t}\t\r\n\t\r\n\t/* Get list of wildcards associated with word. */\r\n\tpublic static ArrayList<String> getWildcardRoots(String w) {\r\n\t\tArrayList<String> words = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < w.length(); i++) {\r\n\t\t\tString word = w.substring(0, i) + \"_\" + w.substring(i + 1);\r\n\t\t\twords.add(word);\r\n\t\t}\r\n\t\treturn words;\r\n\t}\t\r\n\t\r\n\r\n\t\r\n\t/* Return words that are one edit away. */\r\n\tpublic static ArrayList<String> getValidLinkedWords(String word, HashMapList<String, String> wildcardToWords) {\r\n\t\tArrayList<String> wildcards = getWildcardRoots(word);\r\n\t\tArrayList<String> linkedWords = new ArrayList<String>();\r\n\t\tfor (String wildcard : wildcards) {\r\n\t\t\tArrayList<String> words = wildcardToWords.get(wildcard);\r\n\t\t\tfor (String linkedWord : words) {\r\n\t\t\t\tif (!linkedWord.equals(word)) {\r\n\t\t\t\t\tlinkedWords.add(linkedWord);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn linkedWords;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tString[] words = {\"maps\", \"tan\", \"tree\", \"apple\", \"cans\", \"help\", \"aped\", \"pree\", \"pret\", \"apes\", \"flat\", \"trap\", \"fret\", \"trip\", \"trie\", \"frat\", \"fril\"};\t\t\r\n\t\tLinkedList<String> list = transform(\"tree\", \"flat\", words);\r\n\t\t\r\n\t\tif (list == null) {\r\n\t\t\tSystem.out.println(\"No path.\");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(list.toString());\r\n\t\t}\r\n\t}\r\n\r\n}\r\n","Chapter":"Q17_22_Word_Transformer"}