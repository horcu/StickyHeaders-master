{"Id":"51fbc647-ce42-4a2b-9b28-df2b1ff39a8d","Topic":"QuestionD.java","Question":"","Solution":"package Q17_14_Smallest_K;\n\nimport java.util.Random;\n\nimport CtCILibrary.AssortedMethods;\n\npublic class QuestionD {\n\tpublic static class PartitionResult {\n\t\tint leftSize;\n\t\tint middleSize;\n\t\tpublic PartitionResult(int left, int middle) {\n\t\t\tthis.leftSize = left;\n\t\t\tthis.middleSize = middle;\n\t\t}\n\t}\n\t\n\tpublic static int[] smallestK(int[] array, int k) {\n\t\tif (k <= 0 || k > array.length) throw new IllegalArgumentException();\n\t\t\n\t\tint threshold = rank(array, k - 1);\n\t\tint[] smallest = new int[k];\n\t\tint count = 0;\n\t\tfor (int a : array) {\n\t\t\tif (a < threshold) {\n\t\t\t\tsmallest[count] = a;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (count < k) {\n\t\t\tsmallest[count] = threshold;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\treturn smallest;\n\t}\t\n\t\n\t/* Find value with rank k in array. */\n\tpublic static int rank(int[] array, int k) {\n\t\tif (k >= array.length) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\treturn rank(array, k, 0, array.length - 1);\n\t}\n \n\t/* Find value with rank k in sub array between start and end. */\n\tprivate static int rank(int[] array, int k, int start, int end) {\n\t\t/* Partition array around an arbitrary pivot. */\n\t\tint pivot = array[randomIntInRange(start, end)];\n\t\tPartitionResult partition = partition(array, start, end, pivot);\n\t\tint leftSize = partition.leftSize;\n\t\tint middleSize = partition.middleSize;\n\t\t\n\t\tif (k < leftSize) { // Rank k is on left half\n\t\t\treturn rank(array, k, start, start + leftSize - 1);\n\t\t} else if (k < leftSize + middleSize) { // Rank k is in middle\n\t\t\treturn pivot; // middle is all pivot values\n\t\t} else { // Rank k is on right\n\t\t\treturn rank(array, k - leftSize - middleSize, start + leftSize + middleSize, end);\n\t\t}\n\t}\n \n\t/* Partition result into < pivot, equal to pivot -> bigger than pivot. */\n\tprivate static PartitionResult partition(int[] array, int start, int end, int pivot) {\n\t\tint left = start; /* Stays at (right) edge of left side. */\n\t\tint right = end;  /* Stays at (left) edge of right side. */\n\t\tint middle = start; /* Stays at (right) edge of middle. */\n\t\twhile (middle <= right) {\n\t\t\tif (array[middle] < pivot) {\n\t\t\t\t/* Middle is smaller than the pivot. Left is either \n\t\t\t\t * smaller or equal to the pivot. Either way, swap\n\t\t\t\t * them. Then middle and left should move by one.\n\t\t\t\t */\n\t\t\t\tswap(array, middle, left);\n\t\t\t\tmiddle++;\n\t\t\t\tleft++;\n\t\t\t} else if (array[middle] > pivot) {\n\t\t\t\t/* Middle is bigger than the pivot. Right could have\n\t\t\t\t * any value. Swap them, then we know that the new\n\t\t\t\t * right is bigger than the pivot. Move right by one.\n\t\t\t\t */\n\t\t\t\tswap(array, middle, right);\n\t\t\t\tright--;\n\t\t\t} else if (array[middle] == pivot) {\n\t\t\t\t/* Middle is equal to the pivot. Move by one. */\n\t\t\t\tmiddle++;\n\t\t\t}\n\t\t}\n\t\t/* Return sizes of left and middle. */\n\t\treturn new PartitionResult(left - start, right - left + 1);\n\t}\n\t\n\tpublic static int randomIntInRange(int min, int max) {\n\t\tRandom rand = new Random();\n\t\treturn rand.nextInt(max + 1 - min) + min;\n\t}\t\n \n\t/* Swap values at index i and j. */\n\tpublic static void swap(int[] array, int i, int j) {\n\t\tint t = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = t;\n\t}\t\n\t\n\tpublic static void main(String[] args) {\n\t\tint[] array = {1, 5, 2, 3, 2, 9, -1, 11, 6, 13, 15, 2};\n\t\tint[] smallest = smallestK(array, 6);\n\t\tSystem.out.println(AssortedMethods.arrayToString(smallest));\n\t}\n}\n","Chapter":"Q17_14_Smallest_K"}