{"Id":"a262c1f5-c6c6-41f0-a73c-b861b49357c6","Topic":"QuestionD.java","Question":"","Solution":"package Q17_18_Shortest_Supersequence;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\nimport CtCILibrary.HashMapList;\n\npublic class QuestionD {\n\n\tpublic static Range getShortestClosure(ArrayList<Queue<Integer>> lists) {\n\t\tPriorityQueue<HeapNode> minHeap = new PriorityQueue<HeapNode>();\n\t\tint max = Integer.MIN_VALUE;\n\t\t\n\t\t/* Insert min element from each list. */ \n\t\tfor (int i = 0; i < lists.size(); i++) {\n\t\t\tint head = lists.get(i).remove();\n\t\t\tminHeap.add(new HeapNode(head, i));\n\t\t\tmax = Math.max(max, head);\n\t\t}\n\t\t\n\t\tint min = minHeap.peek().locationWithinList;\n\t\tint bestRangeMin = min;\n\t\tint bestRangeMax = max;\n\t\t\n\t\twhile (true) {\n\t\t\t/* Remove min node. */\n\t\t\tHeapNode n = minHeap.poll();\n\t\t\tQueue<Integer> list = lists.get(n.listId);\n\t\t\t\n\t\t\t/* Compare range to best range. */\n\t\t\tmin = n.locationWithinList;\n\t\t\tif (max - min < bestRangeMax - bestRangeMin) {\n\t\t\t\tbestRangeMax = max;\n\t\t\t\tbestRangeMin = min;\n\t\t\t}\n\t\t\t\n\t\t\t/* If there are no more elements, then there's no more subsequences and we can break. */\n\t\t\tif (list.size() == 0) {\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\t/* Add new head of list to heap. */\n\t\t\tn.locationWithinList = list.remove();\n\t\t\tminHeap.add(n);\n\t\t\tmax = Math.max(max, n.locationWithinList);\n\t\t}\n\t\t\n\t\treturn new Range(bestRangeMin, bestRangeMax);\n\t}\n\t\n\t/* Get list of queues (linked lists) storing the indices at which\n\t * each element in smallArray appears in bigArray. */\n\tpublic static ArrayList<Queue<Integer>> getLocationsForElements(int[] big, int[] small) {\n\t\t/* Initialize hash map from item value to locations. */\n\t\tHashMap<Integer, Queue<Integer>> itemLocations = new HashMap<Integer, Queue<Integer>>();\n\t\tfor (int s : small) {\n\t\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\t\titemLocations.put(s, queue);\n\t\t}\n\t\t\n\t\t/* Walk through big array, adding the item locations to hash map */\n\t\tfor (int i = 0; i < big.length; i++) {\n\t\t\tQueue<Integer> queue = itemLocations.get(big[i]);\n\t\t\tif (queue != null) {\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Queue<Integer>> allLocations = new ArrayList<Queue<Integer>>();\n\t\tallLocations.addAll(itemLocations.values());\n\t\treturn allLocations;\n\t}\n\t\n\tpublic static Range shortestSupersequence(int[] big, int[] small) {\n\t\tArrayList<Queue<Integer>> locations = getLocationsForElements(big, small);\n\t\tif (locations == null) return null;\n\t\treturn getShortestClosure(locations);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint[] array = {7, 5, 9, 0, 2, 1, 3, 5, 7, 9, 1, 1, 5, 8, 8, 9, 7};\n\t\tint[] set = {1, 5, 9};\n\t\tSystem.out.println(array.length);\n\t\tRange shortest = shortestSupersequence(array, set);\n\t\tif (shortest == null) {\n\t\t\tSystem.out.println(\"not found\");\n\t\t} else {\n\t\t\tSystem.out.println(shortest.getStart() + \", \" + shortest.getEnd());\n\t\t}\n\t}\n\n}\n","Chapter":"Q17_18_Shortest_Supersequence"}