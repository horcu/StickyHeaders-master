{"Id":"05cdb9c2-61fd-48c0-b5d9-056117b6f5c7","Topic":"Ch 02. Linked Lists","Question":"","Solution":"package Q2_01_Remove_Dups;\r\n\r\nimport CtCILibrary.LinkedListNode;\r\n\r\npublic class QuestionC {\r\n\tpublic static void deleteDups(LinkedListNode head) {\r\n\t\tif (head == null) return;\r\n\t\tLinkedListNode previous = head;\r\n\t\tLinkedListNode current = previous.next;\r\n\t\twhile (current != null) {\r\n\t\t\t// Look backwards for dups, and remove any that you see.\r\n\t\t\tLinkedListNode runner = head;\r\n\t\t\twhile (runner != current) { \r\n\t\t\t\tif (runner.data == current.data) {\r\n\t\t\t\t\tLinkedListNode tmp = current.next;\r\n\t\t\t\t\tprevious.next = tmp;\r\n\t\t\t\t\tcurrent = tmp;\r\n\t\t\t\t\t/* We know we can't have more than one dup preceding\r\n\t\t\t\t\t * our element since it would have been removed \r\n\t\t\t\t\t * earlier. */\r\n\t\t\t\t    break;\r\n\t\t\t\t}\r\n\t\t\t\trunner = runner.next;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/* If runner == current, then we didn't find any duplicate \r\n\t\t\t * elements in the previous for loop.  We then need to \r\n\t\t\t * increment current.  \r\n\t\t\t * If runner != current, then we must have hit the �break� \r\n\t\t\t * condition, in which case we found a dup and current has\r\n\t\t\t * already been incremented.*/\r\n\t\t\tif (runner == current) {\r\n\t\t\t\tprevious = current;\r\n\t\t        current = current.next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\t\r\n\t\tLinkedListNode first = new LinkedListNode(0, null, null); //AssortedMethods.randomLinkedList(1000, 0, 2);\r\n\t\tLinkedListNode head = first;\r\n\t\tLinkedListNode second = first;\r\n\t\tfor (int i = 1; i < 8; i++) {\r\n\t\t\tsecond = new LinkedListNode(i % 2, null, null);\r\n\t\t\tfirst.setNext(second);\r\n\t\t\tsecond.setPrevious(first);\r\n\t\t\tfirst = second;\r\n\t\t}\r\n\t\tSystem.out.println(head.printForward());\r\n\t\tdeleteDups(head);\r\n\t}\r\n}\r\n","Chapter":"Ch 02. Linked Lists"}