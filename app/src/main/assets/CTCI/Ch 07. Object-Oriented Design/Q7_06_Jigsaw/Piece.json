{"Id":"ec816334-c4ee-4062-93ee-df07908f2bbc","Topic":"Ch 07. Object-Oriented Design","Question":"","Solution":"package Q7_06_Jigsaw;\n\nimport java.util.HashMap;\nimport java.util.Map.Entry;\n\npublic class Piece {\n\tprivate final static int NUMBER_OF_EDGES = 4;\n\tprivate HashMap<Orientation, Edge> edges = new HashMap<Orientation, Edge>();\n\t\n\tpublic Piece(Edge[] edgeList) {\t\t\n\t\tOrientation[] orientations = Orientation.values();\n\t\tfor (int i = 0; i < edgeList.length; i++) {\n\t\t\tEdge edge = edgeList[i];\n\t\t\tedge.setParentPiece(this);\t\n\t\t\tedges.put(orientations[i], edge);\n\t\t}\n\t}\n\t\n\t/* Set this edge in the appropriate orientation, rotating the piece as necessary. */\n\tpublic void setEdgeAsOrientation(Edge edge, Orientation orientation) {\n\t\tOrientation currentOrientation = getOrientation(edge);\n\t\trotateEdgesBy(orientation.ordinal() - currentOrientation.ordinal());\n\t}\n\t\n\t/* Return the current orientation of the edge. */\n\tprivate Orientation getOrientation(Edge edge) {\n\t\tfor (Entry<Orientation, Edge> entry : edges.entrySet()) {\n\t\t\tif (entry.getValue() == edge) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/* Rotate edges by \"numberRotations\". */\n\tpublic void rotateEdgesBy(int numberRotations) {\n\t\tOrientation[] orientations = Orientation.values();\n\t\tHashMap<Orientation, Edge> rotated = new HashMap<Orientation, Edge>();\n\t\t\n\t\tnumberRotations = numberRotations % NUMBER_OF_EDGES;\n\t\tif (numberRotations < 0) numberRotations += NUMBER_OF_EDGES;\n\t\t\n\t\tfor (int i = 0; i < orientations.length; i++) {\n\t\t\tOrientation oldOrientation = orientations[(i - numberRotations + NUMBER_OF_EDGES) % NUMBER_OF_EDGES];\n\t\t\tOrientation newOrientation = orientations[i];\n\t\t\trotated.put(newOrientation, edges.get(oldOrientation));\n\t\t}\t\t\n\t\tedges = rotated;\n\t}\n\t\n\t/* Check if this piece is a corner piece. */\n\tpublic boolean isCorner() {\n\t\tOrientation[] orientations = Orientation.values();\n\t\tfor (int i = 0; i < orientations.length; i++) {\n\t\t\tShape current = edges.get(orientations[i]).getShape();\n\t\t\tShape next = edges.get(orientations[(i + 1) % NUMBER_OF_EDGES]).getShape();\n\t\t\tif (current == Shape.FLAT && next == Shape.FLAT) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/* Check if this piece has a border edge. */\n\tpublic boolean isBorder() {\n\t\tOrientation[] orientations = Orientation.values();\n\t\tfor (int i = 0; i < orientations.length; i++) {\n\t\t\tif (edges.get(orientations[i]).getShape() == Shape.FLAT) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/* Get edge at this orientation. */\n\tpublic Edge getEdgeWithOrientation(Orientation orientation) {\n\t\treturn edges.get(orientation);\n\t}\t\n\t\n\t/* Return the edge that matches targetEdge. Returns null if there is no match. */\n\tpublic Edge getMatchingEdge(Edge targetEdge) {\n\t\tfor (Edge e : edges.values()) {\n\t\t\tif (targetEdge.fitsWith(e)) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tOrientation[] orientations = Orientation.values();\n\t\tfor (Orientation o : orientations) {\n\t\t\tsb.append(edges.get(o).toString() + \",\");\n\t\t}\n\t\treturn \"[\" + sb.toString() + \"]\";\n\t}\n}\n","Chapter":"Ch 07. Object-Oriented Design"}