{"Id":"d9344f21-b747-47d8-b679-b4598a545f22","Topic":"Ch 07. Object-Oriented Design","Question":"","Solution":"package Q7_06_Jigsaw;\n\nimport java.util.LinkedList;\n\npublic class Puzzle {\n\tprivate LinkedList<Piece> pieces; /* Remaining pieces left to put away. */ \n\tprivate Piece[][] solution;\n\tprivate int size;\n\t\n\tpublic Puzzle(int size, LinkedList<Piece> pieces) {\n\t\tthis.pieces = pieces;\n\t\tthis.size = size;\n\t}\n\t\n\t/* Group pieces into border pieces (including corners) and inside pieces. */\n\tpublic void groupPieces(LinkedList<Piece> cornerPieces, LinkedList<Piece> borderPieces, LinkedList<Piece> insidePieces) {\n\t\tfor (Piece p : pieces) {\n\t\t\tif (p.isCorner()) {\n\t\t\t\tcornerPieces.add(p);\n\t\t\t} else if (p.isBorder()) {\n\t\t\t\tborderPieces.add(p);\n\t\t\t} else {\n\t\t\t\tinsidePieces.add(p);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* Orient this corner piece so that its flat edges are on the top and left. */ \n\tpublic void orientTopLeftCorner(Piece piece) {\n\t\tif (!piece.isCorner()) return;\n\t\t\n\t\tOrientation[] orientations = Orientation.values();\n\t\tfor (int i = 0; i < orientations.length; i++) {\n\t\t\tEdge current = piece.getEdgeWithOrientation(orientations[i]);\n\t\t\tEdge next = piece.getEdgeWithOrientation(orientations[(i + 1) % orientations.length]);\n\t\t\tif (current.getShape() == Shape.FLAT && next.getShape() == Shape.FLAT) {\n\t\t\t\tpiece.setEdgeAsOrientation(current, Orientation.LEFT);\n\t\t\t\treturn;\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\t/* Bounds check. Check if this index is on a border (0 or size - 1) */\n\tpublic boolean isBorderIndex(int location) {\n\t\treturn location == 0 || location == size - 1;\n\t}\n\t\n\t/* Given a list of pieces, check if any have an edge that matches this piece. Return the edge*/\n\tprivate Edge getMatchingEdge(Edge targetEdge, LinkedList<Piece> pieces) {\n\t\tfor (Piece piece : pieces) {\n\t\t\tEdge matchingEdge = piece.getMatchingEdge(targetEdge);\n\t\t\tif (matchingEdge != null) {\n\t\t\t\treturn matchingEdge;\n\t\t\t}\n\t\t}\t\n\t\treturn null;\n\t}\n\t\n\t/* Put the edge/piece into the solution, turn it appropriately, and remove from list. */ \n\tprivate void setEdgeInSolution(LinkedList<Piece> pieces, Edge edge, int row, int column, Orientation orientation) {\n\t\tPiece piece = edge.getParentPiece();\n\t\tpiece.setEdgeAsOrientation(edge, orientation);\n\t\tpieces.remove(piece);\n\t\tsolution[row][column] = piece;\n\t}\n\t\n\t/* Return the list where a piece with this index would be found. */\n\tprivate LinkedList<Piece> getPieceListToSearch(LinkedList<Piece> cornerPieces, LinkedList<Piece> borderPieces, LinkedList<Piece> insidePieces, int row, int column) {\n\t\tif (isBorderIndex(row) && isBorderIndex(column)) {\n\t\t\treturn cornerPieces;\n\t\t} else if (isBorderIndex(row) || isBorderIndex(column)) {\n\t\t\treturn borderPieces;\n\t\t} else {\n\t\t\treturn insidePieces;\n\t\t}\n\t}\n\t\n\t/* Find the matching piece within piecesToSearch and insert it at row, column. */\n\tprivate boolean fitNextEdge(LinkedList<Piece> piecesToSearch, int row, int column) {\n\t\tif (row == 0 && column == 0) {\n\t\t\tPiece p = piecesToSearch.remove();\n\t\t\torientTopLeftCorner(p);\n\t\t\tsolution[0][0] = p;\n\t\t} else {\n\t\t\t/* Get the right edge and list to match. */\n\t\t\tPiece pieceToMatch = column == 0 ? solution[row - 1][0] : solution[row][column - 1];\n\t\t\tOrientation orientationToMatch = column == 0 ? Orientation.BOTTOM : Orientation.RIGHT;\n\t\t\tEdge edgeToMatch = pieceToMatch.getEdgeWithOrientation(orientationToMatch);\n\t\t\t\n\t\t\t/* Get matching edge. */\n\t\t\tEdge edge = getMatchingEdge(edgeToMatch, piecesToSearch);\n\t\t\tif (edge == null) return false; // Can't solve\n\t\t\t\n\t\t\tOrientation orientation = orientationToMatch.getOpposite();\n\t\t\tsetEdgeInSolution(piecesToSearch, edge, row, column, orientation);\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic boolean solve() {\n\t\t/* Group pieces. */\n\t\tLinkedList<Piece> cornerPieces = new LinkedList<Piece>();\n\t\tLinkedList<Piece> borderPieces = new LinkedList<Piece>();\n\t\tLinkedList<Piece> insidePieces = new LinkedList<Piece>();\n\t\tgroupPieces(cornerPieces, borderPieces, insidePieces);\n\t\t\n\t\t/* Walk through puzzle, finding the piece that joins the previous one. */\n\t\tsolution = new Piece[size][size];\t\n\t\tfor (int row = 0; row < size; row++) {\n\t\t\tfor (int column = 0; column < size; column++) {\n\t\t\t\tLinkedList<Piece> piecesToSearch = getPieceListToSearch(cornerPieces, borderPieces, insidePieces, row, column);\n\t\t\t\tif (!fitNextEdge(piecesToSearch, row, column)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\t\n\t\n\tpublic Piece[][] getCurrentSolution() {\n\t\treturn solution;\n\t}\n}\n","Chapter":"Ch 07. Object-Oriented Design"}