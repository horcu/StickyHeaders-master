{"Id":"5b715a0a-18d1-422f-9117-683a79291a75","Topic":"Ch 07. Object-Oriented Design","Question":"","Solution":"package Q7_08_Othello;\r\n\r\npublic class Board {\r\n\tprivate int blackCount = 0;\r\n\tprivate int whiteCount = 0;\r\n\tprivate Piece[][] board;\r\n\t\r\n\tpublic Board(int rows, int columns) {\r\n\t\tboard = new Piece[rows][columns];\r\n\t}\r\n\t\r\n\tpublic void initialize() {\r\n\t\t/* initial board has a grid like the following in the center:\r\n\t\t *     WB\r\n\t\t *     BW\r\n\t\t */\r\n\t\tint middleRow = board.length / 2;\r\n\t\tint middleColumn = board[middleRow].length / 2;\r\n\t\tboard[middleRow][middleColumn] = new Piece(Color.White);\r\n\t\tboard[middleRow + 1][middleColumn] = new Piece(Color.Black);\r\n\t\tboard[middleRow + 1][middleColumn + 1] = new Piece(Color.White);\r\n\t\tboard[middleRow][middleColumn + 1] = new Piece(Color.Black);\r\n\t\tblackCount = 2;\r\n\t\twhiteCount = 2;\r\n\t}\r\n\t\r\n\tpublic boolean placeColor(int row, int column, Color color) {\r\n\t\tif (board[row][column] != null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t/* attempt to flip each of the four directions */\r\n\t\tint[] results = new int[4];\r\n\t\tresults[0] = flipSection(row - 1, column, color, Direction.up);\r\n\t\tresults[1] = flipSection(row + 1, column, color, Direction.down);\r\n\t\tresults[2] = flipSection(row, column + 1, color, Direction.right);\r\n\t\tresults[3] = flipSection(row, column - 1, color, Direction.left);\r\n\t\t\r\n\t\t/* compute how many pieces were flipped */\r\n\t\tint flipped = 0;\r\n\t\tfor (int result : results) {\r\n\t\t\tif (result > 0) {\r\n\t\t\t\tflipped += result;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t/* if nothing was flipped, then it's an invalid move */\r\n\t\tif (flipped < 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t/* flip the piece, and update the score */\r\n\t\tboard[row][column] = new Piece(color);\r\n\t\tupdateScore(color, flipped + 1);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tprivate int flipSection(int row, int column, Color color, Direction d) {\r\n\t\t/* Compute the delta for the row and the column. At all times, only the row or the column\r\n\t\t * will have a delta, since we're only moving in one direction at a time.\r\n\t\t */\r\n\t\tint r = 0;\r\n\t\tint c = 0;\r\n\t\tswitch (d) {\r\n\t\tcase up:\r\n\t\t\tr = -1;\r\n\t\t\tbreak;\r\n\t\tcase down:\r\n\t\t\tr = 1;\r\n\t\t\tbreak;\r\n\t\tcase left:\r\n\t\t\tc = -1;\r\n\t\t\tbreak;\r\n\t\tcase right:\r\n\t\t\tc = 1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\t/* If out of bounds, or nothing to flip, return an error (-1) */\r\n\t\tif (row < 0 || row >= board.length || column < 0 || column >= board[row].length || board[row][column] == null) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\t/* Found same color - return nothing flipped */\r\n\t\tif (board[row][column].getColor() == color) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\t/* Recursively flip the remainder of the row. If -1 is returned, then we know we hit the boundary\r\n\t\t * of the row (or a null piece) before we found our own color, so there's nothing to flip. Return\r\n\t\t * the error code.\r\n\t\t */\r\n\t\tint flipped = flipSection(row + r, column + c, color, d);\r\n\t\tif (flipped < 0) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\t/* flip our own color */\r\n\t\tboard[row][column].flip();\r\n\t\treturn flipped + 1;\r\n\t}\r\n\t\r\n\tpublic int getScoreForColor(Color c) {\r\n\t\tif (c == Color.Black) {\r\n\t\t\treturn blackCount;\r\n\t\t} else {\r\n\t\t\treturn whiteCount;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void updateScore(Color newColor, int newPieces) {\r\n\t\t/* If we added x pieces of a color, then we actually removed x - 1 pieces of the other\r\n\t\t * color. The -1 is because one of the new pieces was the just-placed one.\r\n\t\t */\r\n\t\tif (newColor == Color.Black) {\r\n\t\t\twhiteCount -= newPieces - 1;\r\n\t\t\tblackCount += newPieces;\r\n\t\t} else {\r\n\t\t\tblackCount -= newPieces - 1;\t\t\t\r\n\t\t\twhiteCount += newPieces;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic void printBoard() {\r\n\t\tfor (int r = 0; r < board.length; r++) {\r\n\t\t\tfor (int c = 0; c < board[r].length; c++) {\r\n\t\t\t\tif (board[r][c] == null) {\r\n\t\t\t\t\tSystem.out.print(\"_\");\r\n\t\t\t\t} else if (board[r][c].getColor() == Color.White) {\r\n\t\t\t\t\tSystem.out.print(\"W\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tSystem.out.print(\"B\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSystem.out.println();\r\n\t\t}\r\n\t}\r\n}\r\n","Chapter":"Ch 07. Object-Oriented Design"}