{"Id":"146ca456-b222-46d2-b30c-c15c76abe6ab","Topic":"Ch 07. Object-Oriented Design","Question":"","Solution":"package Q7_02_Call_Center;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/* CallHandler represents the body of the program,\r\n * and all calls are funneled first through it. \r\n */\r\npublic class CallHandler {\t\r\n\t/* We have 3 levels of employees: respondents, managers, directors. */\r\n    private final int LEVELS = 3; \r\n    \r\n    /* Initialize with 10 respondents, 4 managers, and 2 directors. */\r\n    private final int NUM_RESPONDENTS = 10;\r\n    private final int NUM_MANAGERS = 4;\r\n    private final int NUM_DIRECTORS = 2;\r\n\r\n    /* List of employees, by level.\r\n     * employeeLevels[0] = respondents\r\n     * employeeLevels[1] = managers\r\n     * employeeLevels[2] = directors\r\n     */\r\n    List<List<Employee>> employeeLevels;\r\n\r\n\t/* queues for each callï¿½s rank */\r\n    List<List<Call>> callQueues; \r\n\r\n    public CallHandler() {\r\n    \temployeeLevels = new ArrayList<List<Employee>>(LEVELS);\r\n    \tcallQueues = new ArrayList<List<Call>>(LEVELS); \r\n    \t\r\n        // Create respondents.\r\n        ArrayList<Employee> respondents = new ArrayList<Employee>(NUM_RESPONDENTS);\r\n        for (int k = 0; k < NUM_RESPONDENTS - 1; k++) {\r\n            respondents.add(new Respondent(this));\r\n        }\r\n        employeeLevels.add(respondents);\r\n\r\n        // Create managers.\r\n        ArrayList<Employee> managers = new ArrayList<Employee>(NUM_MANAGERS);\r\n        managers.add(new Manager(this));\r\n        employeeLevels.add(managers);\r\n\r\n        // Create directors.\r\n        ArrayList<Employee> directors = new ArrayList<Employee>(NUM_DIRECTORS);\r\n        directors.add(new Director(this));\r\n        employeeLevels.add(directors);\r\n    }\r\n    \r\n    /* Gets the first available employee who can handle this call. */\r\n    public Employee getHandlerForCall(Call call) {\r\n        for (int level = call.getRank().getValue(); level < LEVELS - 1; level++) {\r\n            List<Employee> employeeLevel = employeeLevels.get(level);\r\n            for (Employee emp : employeeLevel) {\r\n                if (emp.isFree()) {\r\n                    return emp;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /* Routes the call to an available employee, or saves in a queue if no employee available. */\r\n    public void dispatchCall(Caller caller) {\r\n    \tCall call = new Call(caller);\r\n    \tdispatchCall(call);\r\n    }\r\n    \r\n    /* Routes the call to an available employee, or saves in a queue if no employee available. */\r\n    public void dispatchCall(Call call) {\r\n    \t/* Try to route the call to an employee with minimal rank. */\r\n        Employee emp = getHandlerForCall(call);\r\n        if (emp != null) {\r\n        \temp.receiveCall(call);\r\n        \tcall.setHandler(emp);\r\n        } else {\r\n\t        /* Place the call into corresponding call queue according to its rank. */\r\n\t        call.reply(\"Please wait for free employee to reply\");\r\n\t        callQueues.get(call.getRank().getValue()).add(call);\r\n        }\r\n    }    \r\n\r\n    /* An employee got free. Look for a waiting call that he/she can serve. Return true\r\n     * if we were able to assign a call, false otherwise. */\r\n    public boolean assignCall(Employee emp) {\r\n        /* Check the queues, starting from the highest rank this employee can serve. */\r\n        for (int rank = emp.getRank().getValue(); rank >= 0; rank--) {\r\n            List<Call> que = callQueues.get(rank);\r\n            \r\n            /* Remove the first call, if any */\r\n            if (que.size() > 0) {\r\n\t            Call call = que.remove(0); \r\n\t            if (call != null) {\r\n\t                emp.receiveCall(call);\r\n\t                return true;\r\n\t            }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n","Chapter":"Ch 07. Object-Oriented Design"}