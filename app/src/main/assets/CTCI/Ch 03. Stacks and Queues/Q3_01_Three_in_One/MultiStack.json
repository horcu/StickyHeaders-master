{"Id":"b2ce7613-7e71-49e5-8912-4d85c9f6104c","Topic":"Ch 03. Stacks and Queues","Question":"","Solution":"package Q3_01_Three_in_One;\n\nimport java.util.EmptyStackException;\n\nimport CtCILibrary.AssortedMethods;\n\npublic class MultiStack {\n\t/* StackInfo is a simple class that holds a set of data about \n\t * each stack. It does not hold the actual items in the stack. \n\t * We could have done this with just a bunch of individual \n\t * variables, but that’s messy and doesn’t gain us much. */\n\tprivate class StackInfo {\n\t\tpublic int start, size, capacity;\n\t\tpublic StackInfo(int start, int capacity) {\n\t\t\tthis.start = start;\n\t\t\tthis.capacity = capacity;\n\t\t}\n\t\t\n\t\t/* Check if an index on the full array is within the stack\n\t\t * boundaries. The stack can wrap around to the start of \n\t\t * the array. */\n\t\tpublic boolean isWithinStackCapacity(int index) {\n\t\t\t/* If outside of bounds of array, return false. */\n\t\t\tif (index < 0 || index >= values.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t/* If index wraps around, adjust it. */\n\t\t\tint contiguousIndex = index < start ? index + values.length : index;\n\t\t\tint end = start + capacity;\n\t\t\treturn start <= contiguousIndex && contiguousIndex < end;\n\t\t}\n\t\t\n\t\tpublic int lastCapacityIndex() {\n\t\t\treturn adjustIndex(start + capacity - 1);\n\t\t}\n\t\t\n\t\tpublic int lastElementIndex() {\n\t\t\treturn adjustIndex(start + size - 1);\n\t\t}\t\t\n\t\t\n\t\tpublic boolean isFull() {\n\t\t\treturn size == capacity;\n\t\t}\n\t\t\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\t}\n\t\n\tprivate StackInfo[] info;\n\tprivate int[] values;\n\t\n\tpublic MultiStack(int numberOfStacks, int defaultSize) {\n\t\t/* Create metadata for all the stacks. */\n\t\tinfo = new StackInfo[numberOfStacks];\n\t\tfor (int i = 0; i < numberOfStacks; i++) {\n\t\t\tinfo[i] = new StackInfo(defaultSize * i, defaultSize);\n\t\t}\n\t\tvalues = new int[numberOfStacks * defaultSize];\n\t}\t\n\t\n\t/* Returns the number of items actually present in stack. */\n\tpublic int numberOfElements() {\n\t\tint size = 0;\n\t\tfor (StackInfo sd : info) {\n\t\t\tsize += sd.size;\n\t\t}\n\t\treturn size;\n\t}\n\t\n\t/* Returns true is all the stacks are full. */\n\tpublic boolean allStacksAreFull() {\n\t\treturn numberOfElements() == values.length;\n\t}\n\t\n\t/* Adjust index to be within the range of 0 -> length - 1. */\n\tprivate int adjustIndex(int index) {\n\t\t/* Java's mod operator can return neg values. For example,\n\t\t * (-11 % 5) will return -1, not 4. We actually want the \n\t\t * value to be 4 (since we're wrapping around the index). \n\t\t */\n\t\tint max = values.length;\n\t\treturn ((index % max) + max) % max;\n\t}\n\t\n\t/* Get index after this index, adjusted for wrap around. */\n\tprivate int nextIndex(int index) {\n\t\treturn adjustIndex(index + 1);\n\t}\n\t\n\t/* Get index before this index, adjusted for wrap around. */\n\tprivate int previousIndex(int index) {\n\t\treturn adjustIndex(index - 1);\n\t}\n\t\n\t/* Shift items in stack over by one element. If we have \n\t * available capacity, then we'll end up shrinking the stack \n\t * by one element. If we don't have available capacity, then\n\t * we'll need to shift the next stack over too. */\n\tprivate void shift(int stackNum) {\n\t\tSystem.out.println(\"/// Shifting \" + stackNum);\n\t\tStackInfo stack = info[stackNum];\n\t\t\n\t\t/* If this stack is at its full capacity, then you need\n\t\t * to move the next stack over by one element. This stack\n\t\t * can now claim the freed index. */\n\t\tif (stack.size >= stack.capacity) {\n\t\t\tint nextStack = (stackNum + 1) % info.length;\n\t\t\tshift(nextStack); \n\t\t\tstack.capacity++; // claim index that next stack lost\n\t\t}\n\t\t\n\t\t/* Shift all elements in stack over by one. */\n\t\tint index = stack.lastCapacityIndex();\n\t\twhile (stack.isWithinStackCapacity(index)) {\n\t\t\tvalues[index] = values[previousIndex(index)];\n\t\t\tindex = previousIndex(index);\n\t\t}\n\t\t\n\t\t/* Adjust stack data. */\n\t\tvalues[stack.start] = 0; // Clear item\n\t\tstack.start = nextIndex(stack.start); // move start\n\t\tstack.capacity--; // Shrink capacity\n\t}\n\t\n\t/* Expand stack by shifting over other stacks */\n\tprivate void expand(int stackNum) {\n\t\tSystem.out.println(\"/// Expanding stack \" + stackNum);\n\t\t\n\t\tshift((stackNum + 1) % info.length);\n\t\tinfo[stackNum].capacity++;\n\t}\n\n\t/* Push value onto stack num, shifting/expanding stacks as \n\t * necessary. Throws exception if all stacks are full. */\n\tpublic void push(int stackNum, int value) throws FullStackException {\n\t\tSystem.out.println(\"/// Pushing stack \" + stackNum + \": \" + value);\n\t\tif (allStacksAreFull()) {\n\t\t\tthrow new FullStackException();\n\t\t}\n\t\t\n\t\t/* If this stack is full, expand it. */\n\t\tStackInfo stack = info[stackNum];\n\t\tif (stack.isFull()) {\n\t\t\texpand(stackNum);\n\t\t}\n\t\t\n\t\t/* Find the index of the top element in the array + 1, \n\t\t * and increment the stack pointer */\t\n\t\tstack.size++;\t\n\t\tvalues[stack.lastElementIndex()] = value;\t\n\t}\n\n\t/* Remove value from stack. */\n\tpublic int pop(int stackNum) throws Exception {\n\t\tSystem.out.println(\"/// Popping stack \" + stackNum);\n\t\tStackInfo stack = info[stackNum];\t\t\n\t\tif (stack.isEmpty()) {\n\t\t\tthrow new EmptyStackException();\n\t\t}\n\n\t\t/* Remove last element. */\n\t\tint value = values[stack.lastElementIndex()];\n\t\tvalues[stack.lastElementIndex()] = 0; // Clear item\n\t\tstack.size--; // Shrink size\n\t\treturn value;\n\t}\n\n\t/* Get top element of stack.*/\n\tpublic int peek(int stackNum) {\n\t\tStackInfo stack = info[stackNum];\t\t\t\n\t\treturn values[stack.lastElementIndex()];\n\t}\n\t\n\tpublic int[] getValues() {\n\t\treturn values;\n\t}\n\t\n\tpublic int[] getStackValues(int stackNum) {\n\t\tStackInfo stack = info[stackNum];\n\t\tint[] items = new int[stack.size];\n\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\titems[i] = values[adjustIndex(stack.start + i)];\n\t\t}\n\t\treturn items;\n\t}\n\t\n\tpublic String stackToString(int stackNum) {\n\t\tint[] items = getStackValues(stackNum);\n\t\treturn stackNum + \": \" + AssortedMethods.arrayToString(items);\n\t}\n}\n","Chapter":"Ch 03. Stacks and Queues"}