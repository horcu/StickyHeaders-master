{"Id":"f5755543-853e-4526-8e80-9c760944ea2b","Topic":"Ch 17. Hard","Question":"","Solution":"package Q17_22_Word_Transformer;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedList;\r\n\r\nimport CtCILibrary.HashMapList;\r\n\r\npublic class QuestionC {\r\n\t\r\n\tpublic static LinkedList<String> transform(String startWord, String stopWord, String[] words) {\r\n\t\tHashMapList<String, String> wildcardToWordList = getWildcardToWordList(words);\r\n\t\t\r\n\t\tBFSData sourceData = new BFSData(startWord);\r\n\t\tBFSData destData = new BFSData(stopWord);\r\n\t\t\r\n\t\twhile (!sourceData.isFinished() && !destData.isFinished()) {\r\n\t\t\t/* Search out from source. */\r\n\t\t\tString collision = searchLevel(wildcardToWordList, sourceData, destData);\r\n\t\t\tif (collision != null) {\r\n\t\t\t\treturn mergePaths(sourceData, destData, collision);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/* Search out from destination. */\r\n\t\t\tcollision = searchLevel(wildcardToWordList, destData, sourceData);\r\n\t\t\tif (collision != null) {\r\n\t\t\t\treturn mergePaths(sourceData, destData, collision);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/* Search one level and return collision, if any. */\r\n\tpublic static String searchLevel(HashMapList<String, String> wildcardToWordList, BFSData primary, BFSData secondary) {\r\n\t\t/* We only want to search one level at a time. Count how many nodes are currently in the primary's\r\n\t\t * level and only do that many nodes. We'll continue to add nodes to the end. */\r\n\t\tint count = primary.toVisit.size(); \r\n\t\tfor (int i = 0; i < count; i++) {\r\n\t\t\t/* Pull out first node. */\r\n\t\t\tPathNode pathNode = primary.toVisit.poll();\r\n\t\t\tString word = pathNode.getWord();\r\n\t\t\t\r\n\t\t\t/* Check if it's already been visited. */\r\n\t\t\tif (secondary.visited.containsKey(word)) {\r\n\t\t\t\treturn pathNode.getWord();\r\n\t\t\t}\t\t\t\t\r\n\t\t\t\r\n\t\t\t/* Add friends to queue. */\r\n\t\t\tArrayList<String> words = getValidLinkedWords(word, wildcardToWordList);\r\n\t\t\tfor (String w : words) {\r\n\t\t\t\tif (!primary.visited.containsKey(w)) {\r\n\t\t\t\t\tPathNode next = new PathNode(w, pathNode);\r\n\t\t\t\t\tprimary.visited.put(w, next);\r\n\t\t\t\t\tprimary.toVisit.add(next);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\tpublic static LinkedList<String> mergePaths(BFSData bfs1, BFSData bfs2, String connection) {\r\n\t\tPathNode end1 = bfs1.visited.get(connection); // end1 -> source\r\n\t\tPathNode end2 = bfs2.visited.get(connection); // end2 -> dest\r\n\t\tLinkedList<String> pathOne = end1.collapse(false); // forward: source -> connection\r\n\t\tLinkedList<String> pathTwo = end2.collapse(true); // reverse: connection -> dest\r\n\t\tpathTwo.removeFirst(); // remove connection\r\n\t\tpathOne.addAll(pathTwo); // add second path\r\n\t\treturn pathOne;\r\n\t}\r\n\t\r\n\tpublic static ArrayList<String> getWildcardRoots(String word) {\r\n\t\tArrayList<String> words = new ArrayList<String>();\r\n\t\tfor (int i = 0; i < word.length(); i++) {\r\n\t\t\tString w = word.substring(0, i) + \"_\" + word.substring(i + 1);\r\n\t\t\twords.add(w);\r\n\t\t}\r\n\t\treturn words;\r\n\t}\t\r\n\t\r\n\tpublic static HashMapList<String, String> getWildcardToWordList(String[] words) {\r\n\t\tHashMapList<String, String> wildcardToWords = new HashMapList<String, String>();\r\n\t\tfor (String word : words) {\r\n\t\t\tArrayList<String> linked = getWildcardRoots(word);\r\n\t\t\tfor (String linkedWord : linked) {\r\n\t\t\t\twildcardToWords.put(linkedWord, word);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn wildcardToWords;\r\n\t}\r\n\t\r\n\tpublic static ArrayList<String> getValidLinkedWords(String word, HashMapList<String, String> wildcardToWords) {\r\n\t\tArrayList<String> wildcards = getWildcardRoots(word);\r\n\t\tArrayList<String> linkedWords = new ArrayList<String>();\r\n\t\tfor (String wildcard : wildcards) {\r\n\t\t\tArrayList<String> words = wildcardToWords.get(wildcard);\r\n\t\t\tfor (String linkedWord : words) {\r\n\t\t\t\tif (!linkedWord.equals(word)) {\r\n\t\t\t\t\tlinkedWords.add(linkedWord);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn linkedWords;\r\n\t}\t\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tString[] words = {\"maps\", \"tan\", \"tree\", \"apple\", \"cans\", \"help\", \"aped\", \"pree\", \"pret\", \"apes\", \"flat\", \"trap\", \"fret\", \"trip\", \"trie\", \"frat\", \"fril\"};\t\t\r\n\t\tLinkedList<String> list = transform(\"tree\", \"flat\", words);\r\n\t\t\r\n\t\tif (list == null) {\r\n\t\t\tSystem.out.println(\"No path.\");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(list.toString());\r\n\t\t}\r\n\t}\r\n\r\n}\r\n","Chapter":"Ch 17. Hard"}