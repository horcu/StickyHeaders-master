{"Id":"078b8594-727b-497a-9838-30f2982dc4b0","Topic":"Ch 16. Moderate","Question":"","Solution":"package Q16_22_Langtons_Ant;\n\npublic class Grid {\t\n\tprivate boolean[][] grid;\n\tprivate Ant ant = new Ant();\n\t\n\tpublic Grid() {\n\t\tgrid = new boolean[1][1];\n\t}\n\t\n\t/* Copy old values into new array, with an offset/shift applied to the row and columns. */\n\tprivate void copyWithShift(boolean[][] oldGrid, boolean[][] newGrid, int shiftRow, int shiftColumn) {\n\t\tfor (int r = 0; r < oldGrid.length; r++) {\n\t\t\tfor (int c = 0; c < oldGrid[0].length; c++) {\n\t\t\t\tnewGrid[r + shiftRow][c + shiftColumn] = oldGrid[r][c];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* Ensure that the given position will fit on the array. If \n\t * necessary, double the size of the matrix, copy the old values \n\t * over, and adjust the ant's position so that it's in a positive\n\t * ranges.\n\t */\n\tprivate void ensureFit(Position position) {\n\t\tint shiftRow = 0;\n\t\tint shiftColumn = 0;\n\t\t\n\t\t/* Calculate new number of rows. */\n\t\tint numRows = grid.length;\n\t\tif (position.row < 0) {\n\t\t\tshiftRow = numRows;\n\t\t\tnumRows *= 2;\n\t\t} else if (position.row >= numRows) {\n\t\t\tnumRows *= 2;\n\t\t}\n\t\t\n\t\t/* Calculate new number of columns. */\n\t\tint numColumns = grid[0].length;\n\t\tif (position.column < 0) {\n\t\t\tshiftColumn = numColumns;\n\t\t\tnumColumns *= 2;\n\t\t} else if (position.column >= numColumns) {\n\t\t\tnumColumns *= 2;\n\t\t}\n\t\t\n\t\t/* Grow array, if necessary. Shift ant's position too. */\n\t\tif (numRows != grid.length || numColumns != grid[0].length) {\n\t\t\tboolean[][] newGrid = new boolean[numRows][numColumns];\n\t\t\tcopyWithShift(grid, newGrid, shiftRow, shiftColumn);\n\t\t\tant.adjustPosition(shiftRow, shiftColumn);\n\t\t\tgrid = newGrid;\n\t\t}\n\t}\n\t\n\t/* Flip color of cells. */\n\tprivate void flip(Position position) {\n\t\tint row = position.row;\n\t\tint column = position.column;\n\t\tgrid[row][column] = grid[row][column] ? false : true;\n\t}\n\t\n\t/* Move ant. */\n\tpublic void move() {\n\t\tant.turn(grid[ant.position.row][ant.position.column]); // Turn\n\t\tflip(ant.position); // flip\n\t\tant.move(); // move\n\t\tensureFit(ant.position); // grow\n\t}\n\t\n\t/* Print board. */\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int r = 0; r < grid.length; r++) {\n\t\t\tfor (int c = 0; c < grid[0].length; c++) {\n\t\t\t\tif (r == ant.position.row && c == ant.position.column) {\n\t\t\t\t\tsb.append(ant.orientation);\n\t\t\t\t} else if (grid[r][c]) {\n\t\t\t\t\tsb.append(\"X\");\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(\"_\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tsb.append(\"Ant: \" + ant.orientation + \". \\n\");\n\t\treturn sb.toString();\n\t}\n}\n","Chapter":"Ch 16. Moderate"}