{"Id":"260d6b8c-792a-4f79-991e-26be3e09cddf","Topic":"Ch 08. Recursion and Dynamic Programming","Question":"","Solution":"package Q8_14_Boolean_Evaluation;\r\n\r\nimport java.util.HashMap;\r\n\r\npublic class Others {\r\n\tpublic enum Term {\r\n\t\tTrue,\r\n\t\tFalse,\r\n\t\tAnd,\r\n\t\tOr,\r\n\t\tXor,\r\n\t\tLeftParen,\r\n\t\tRightParen\r\n\t};\t\r\n\t\r\n\tpublic static String reduce(String expression, int start, int end) {\r\n\t\tif (start == end) {\r\n\t\t\tif (expression.charAt(start) == '1') {\r\n\t\t\t\treturn \"1\";\r\n\t\t\t} else if (expression.charAt(start) == '0') {\r\n\t\t\t\treturn \"0\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tint count = 0;\r\n\t\tint i = 0;\r\n\t\tString[] reduced = new String[3];\r\n\t\tint index = 0;\r\n\t\tint left = start;\r\n\t\tint right = start;\r\n\t\tfor (i = start; i <= end; i++) {\r\n\t\t\tif (expression.charAt(i) == '(') {\r\n\t\t\t\tif (count == 0) {\r\n\t\t\t\t\tleft = i + 1;\r\n\t\t\t\t}\r\n\t\t\t\tcount++;\r\n\t\t\t} else if (expression.charAt(i) == ')') {\r\n\t\t\t\tcount--;\r\n\t\t\t\tif (count == 0) {\r\n\t\t\t\t\tright = i - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (count == 0) {\r\n\t\t\t\treduced[index] = reduce(expression, left, right);\r\n\t\t\t\tif (index == 0) {\r\n\t\t\t\t\treduced[index + 1] = Character.toString(expression.charAt(i + 1));\r\n\t\t\t\t\ti += 1;\r\n\t\t\t\t\tleft = i + 1;\r\n\t\t\t\t\tright = i + 1;\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tindex += 2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (reduced[1].equals(\"&\")) {\r\n\t\t\tif (reduced[0].equals(\"1\") && reduced[2].equals(\"1\")) {\r\n\t\t\t\treturn \"1\";\r\n\t\t\t}\r\n\t\t\treturn \"0\";\r\n\t\t} else if (reduced[1].equals(\"|\")) {\r\n\t\t\tif (reduced[0].equals(\"1\") || reduced[2].equals(\"1\")) {\r\n\t\t\t\treturn \"1\";\r\n\t\t\t}\r\n\t\t\treturn \"0\";\r\n\t\t} else if (reduced[1].equals(\"^\")) {\r\n\t\t\tif (reduced[0].equals(\"1\") && reduced[2].equals(\"0\")) {\r\n\t\t\t\treturn \"1\";\r\n\t\t\t} else if (reduced[0].equals(\"0\") && reduced[2].equals(\"1\")) {\r\n\t\t\t\treturn \"1\";\r\n\t\t\t}\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\treturn \"0\";\r\n\t}\t\r\n\t\r\n\tpublic static boolean evaluate(String expression, int start, int end) {\r\n\t\tString result = reduce(expression, start, end);\r\n\t\tif (result == \"0\") {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static boolean isOperator(char c) {\r\n\t\tswitch (c) {\r\n\t\tcase '&':\r\n\t\tcase '|':\r\n\t\tcase '^':\r\n\t\t\treturn true;\r\n\t\tdefault:\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static String insertParensAround(String expression, int ind) {\r\n\t\tint left = 0;\r\n\t\tint right = 0;\r\n\t\tint index = 0;\r\n\t\tint count = 0;\r\n\t\tfor (int i = 0; i < expression.length(); i++) {\r\n\t\t\tif (isOperator(expression.charAt(i))) {\r\n\t\t\t\tif (count == ind) {\r\n\t\t\t\t\tindex = i;\r\n\t\t\t\t}\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcount = 0;\r\n\t\tfor (int i = index - 1; i >= 0; i--) {\r\n\t\t\tif (expression.charAt(i) == ')') {\r\n\t\t\t\tcount++;\r\n\t\t\t} else if (expression.charAt(i) == '(') {\r\n\t\t\t\tcount--;\r\n\t\t\t}\r\n\t\t\tif (count == 0) {\r\n\t\t\t\tleft = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcount = 0;\r\n\t\tfor (int i = index + 1; i <= expression.length(); i++) {\r\n\t\t\tif (expression.charAt(i) == '(') {\r\n\t\t\t\tcount++;\r\n\t\t\t} else if (expression.charAt(i) == ')') {\r\n\t\t\t\tcount--;\r\n\t\t\t}\r\n\t\t\tif (count == 0) {\r\n\t\t\t\tright = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (left == 0 && right == expression.length() - 1) {\r\n\t\t\treturn expression;\r\n\t\t}\r\n\t\tString newexpression = expression.substring(0, left) + '(' + expression.substring(left, right + 1) + ')' + expression.substring(right + 1);\r\n\t\treturn newexpression;\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static int bruteForce(String expression, HashMap<String, Boolean> completed, boolean result, boolean[] flags) {\r\n\t\tint count = 0;\r\n\t\tboolean isDone = true;\r\n\t\tif (completed.containsKey(expression)) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < flags.length; i++) {\r\n\t\t\tif (!flags[i]) {\r\n\t\t\t\tflags[i] = true;\r\n\t\t\t\tString newexpression = insertParensAround(expression, i);\r\n\t\t\t\tisDone = false;\r\n\t\t\t\tcount += bruteForce(newexpression, completed, result, flags);\r\n\t\t\t\tflags[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isDone) {\r\n\t\t\tif (evaluate(expression, 0, expression.length() - 1) == result) {\r\n\t\t\t\t//System.out.println(expression + \" = \" + result);\r\n\t\t\t\treturn 1;\r\n\t\t\t} else {\r\n\t\t\t\t//System.out.println(expression + \" = \" + !result);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcompleted.put(expression, true);\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\tpublic static int countR(String exp, boolean result, int start, int end) {\r\n\t\tif (start == end) {\r\n\t\t\tif (exp.charAt(start) == '1' && result) {\r\n\t\t\t\treturn 1;\r\n\t\t\t} else if (exp.charAt(start) == '0' && !result) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tint c = 0;\r\n\t\tif (result) {\r\n\t\t\tfor (int i = start + 1; i <= end; i += 2) {\r\n\t\t\t\tchar op = exp.charAt(i);\r\n\t\t\t\tif (op == '&') {\r\n\t\t\t\t\tc += countR(exp, true, start, i - 1) * countR(exp, true, i + 1, end); \r\n\t\t\t\t} else if (op == '|') {\r\n\t\t\t\t\tc += countR(exp, true, start, i - 1) * countR(exp, false, i + 1, end);\r\n\t\t\t\t\tc += countR(exp, false, start, i - 1) * countR(exp, true, i + 1, end);\r\n\t\t\t\t\tc += countR(exp, true, start, i - 1) * countR(exp, true, i + 1, end);\r\n\t\t\t\t} else if (op == '^') {\r\n\t\t\t\t\tc += countR(exp, true, start, i - 1) * countR(exp, false, i + 1, end);\r\n\t\t\t\t\tc += countR(exp, false, start, i - 1) * countR(exp, true, i + 1, end);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = start + 1; i <= end; i += 2) {\r\n\t\t\t\tchar op = exp.charAt(i);\r\n\t\t\t\tif (op == '&') {\r\n\t\t\t\t\tc += countR(exp, false, start, i - 1) * countR(exp, true, i + 1, end);\r\n\t\t\t\t\tc += countR(exp, true, start, i - 1) * countR(exp, false, i + 1, end); \r\n\t\t\t\t\tc += countR(exp, false, start, i - 1) * countR(exp, false, i + 1, end);\r\n\t\t\t\t} else if (op == '|') {\r\n\t\t\t\t\tc += countR(exp, false, start, i - 1) * countR(exp, false, i + 1, end);\r\n\t\t\t\t} else if (op == '^') {\r\n\t\t\t\t\tc += countR(exp, true, start, i - 1) * countR(exp, true, i + 1, end);\r\n\t\t\t\t\tc += countR(exp, false, start, i - 1) * countR(exp, false, i + 1, end);\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\treturn c;\r\n\t}\t\r\n\t\r\n\tpublic static int countDP(String exp, boolean result, int start, int end, HashMap<String, Integer> cache) {\r\n\t\tString key = \"\" + result + start + end;\r\n\t\tif (cache.containsKey(key)) {\r\n\t\t\treturn cache.get(key);\r\n\t\t}\r\n\t\tif (start == end) {\r\n\t\t\tif (exp.charAt(start) == '1' && result == true) {\r\n\t\t\t\treturn 1;\r\n\t\t\t} else if (exp.charAt(start) == '0' && result == false) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tint count = 0;\r\n\t\tif (result) {\r\n\t\t\tfor (int i = start + 1; i <= end; i += 2) {\r\n\t\t\t\tchar op = exp.charAt(i);\r\n\t\t\t\tif (op == '&') {\r\n\t\t\t\t\tcount += countDP(exp, true, start, i - 1, cache) * countDP(exp, true, i + 1, end, cache); \r\n\t\t\t\t} else if (op == '|') {\r\n\t\t\t\t\tcount += countDP(exp, true, start, i - 1, cache) * countDP(exp, false, i + 1, end, cache);\r\n\t\t\t\t\tcount += countDP(exp, false, start, i - 1, cache) * countDP(exp, true, i + 1, end, cache);\r\n\t\t\t\t\tcount += countDP(exp, true, start, i - 1, cache) * countDP(exp, true, i + 1, end, cache);\r\n\t\t\t\t} else if (op == '^') {\r\n\t\t\t\t\tcount += countDP(exp, true, start, i - 1, cache) * countDP(exp, false, i + 1, end, cache);\r\n\t\t\t\t\tcount += countDP(exp, false, start, i - 1, cache) * countDP(exp, true, i + 1, end, cache);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = start + 1; i <= end; i += 2) {\r\n\t\t\t\tchar op = exp.charAt(i);\r\n\t\t\t\tif (op == '&') {\r\n\t\t\t\t\tcount += countDP(exp, false, start, i - 1, cache) * countDP(exp, true, i + 1, end, cache);\r\n\t\t\t\t\tcount += countDP(exp, true, start, i - 1, cache) * countDP(exp, false, i + 1, end, cache); \r\n\t\t\t\t\tcount += countDP(exp, false, start, i - 1, cache) * countDP(exp, false, i + 1, end, cache);\r\n\t\t\t\t} else if (op == '|') {\r\n\t\t\t\t\tcount += countDP(exp, false, start, i - 1, cache) * countDP(exp, false, i + 1, end, cache);\r\n\t\t\t\t} else if (op == '^') {\r\n\t\t\t\t\tcount += countDP(exp, true, start, i - 1, cache) * countDP(exp, true, i + 1, end, cache);\r\n\t\t\t\t\tcount += countDP(exp, false, start, i - 1, cache) * countDP(exp, false, i + 1, end, cache);\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\tcache.put(key, count);\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\tpublic static int total(int n) {\r\n\t\t// Function to return (2n) ! / ((n+1)! * n!)\r\n\t\t\r\n\t\t// To keep the numbers small, we divide by i when possible to do evenly. If not,\r\n\t\t// we store up the remainder and divide when possible.\r\n\t\tlong num = 1;\r\n\t\tlong rem = 1;\r\n\t\tfor (int i = 2; i <= n; i++) {\r\n\t\t\tnum *= (n + i);\r\n\t\t\trem *= i;\r\n\t\t\tif (num % rem == 0) { \r\n\t\t\t\tnum /= rem;\r\n\t\t\t\trem = 1;\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t\treturn (int)num;\r\n\t}\r\n\t\r\n\tpublic static int countDPEff(String exp, boolean result, int start, int end, HashMap<String, Integer> cache) {\r\n\t\tString key = \"\" + start + end;\r\n\t\tint count = 0;\r\n\t\tif (!cache.containsKey(key)) {\r\n\t\t\tif (start == end) {\r\n\t\t\t\tif (exp.charAt(start) == '1') {\r\n\t\t\t\t\tcount = 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount = 0;\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t\t\r\n\t\t\tfor (int i = start + 1; i <= end; i += 2) {\r\n\t\t\t\tchar op = exp.charAt(i);\r\n\t\t\t\tif (op == '&') {\r\n\t\t\t\t\tcount += countDPEff(exp, true, start, i - 1, cache) * countDPEff(exp, true, i + 1, end, cache); \r\n\t\t\t\t} else if (op == '|') {\r\n\t\t\t\t\tint left_ops = (i - 1 - start) / 2; // parens on left\r\n\t\t\t\t\tint right_ops = (end - i - 1) / 2;  // parens on right\r\n\t\t\t\t\tint total_ways = total(left_ops) * total(right_ops);\r\n\t\t\t\t\tint total_false = countDPEff(exp, false, start, i - 1, cache) * countDPEff(exp, false, i + 1, end, cache);\r\n\t\t\t\t\tcount += total_ways - total_false;\r\n\t\t\t\t} else if (op == '^') {\r\n\t\t\t\t\tcount += countDPEff(exp, true, start, i - 1, cache) * countDPEff(exp, false, i + 1, end, cache);\r\n\t\t\t\t\tcount += countDPEff(exp, false, start, i - 1, cache) * countDPEff(exp, true, i + 1, end, cache);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcache.put(key, count);\r\n\t\t} else {\r\n\t\t\tcount = cache.get(key);\r\n\t\t}\r\n\t\tif (result) {\r\n\t\t\treturn count;\r\n\t\t} else {\r\n\t\t\tint num_ops = (end - start) / 2;\r\n\t\t\treturn total(num_ops) - count;\r\n\t\t}\r\n\t}\t\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tString terms = \"0^0|1&1^1|0|1\";\r\n\t\tboolean result = true;\r\n\t\t\r\n\t\tbruteForce(terms, new HashMap<String, Boolean>(), result, new boolean[(terms.length() - 1) / 2]);\r\n\t\tSystem.out.println(countR(terms, result, 0, terms.length() - 1));\r\n\t\tSystem.out.println(countDP(terms, result, 0, terms.length() - 1, new HashMap<String, Integer>()));\r\n\t\tSystem.out.println(countDPEff(terms, result, 0, terms.length() - 1, new HashMap<String, Integer>()));\r\n\t\t\r\n\t}\r\n\r\n}\r\n","Chapter":"Ch 08. Recursion and Dynamic Programming"}