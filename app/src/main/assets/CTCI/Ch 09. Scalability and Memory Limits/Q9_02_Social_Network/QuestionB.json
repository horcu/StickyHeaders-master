{"Id":"531e25a6-54e4-4391-ad4e-c1338273212a","Topic":"Ch 09. Scalability and Memory Limits","Question":"","Solution":"package Q9_02_Social_Network;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class QuestionB {\n\n\tpublic static LinkedList<Person> mergePaths(BFSData bfs1, BFSData bfs2, int connection) {\n\t\tPathNode end1 = bfs1.visited.get(connection); // end1 -> source\n\t\tPathNode end2 = bfs2.visited.get(connection); // end2 -> dest\n\t\tLinkedList<Person> pathOne = end1.collapse(false); // forward: source -> connection\n\t\tLinkedList<Person> pathTwo = end2.collapse(true); // reverse: connection -> dest\n\t\tpathTwo.removeFirst(); // remove connection\n\t\tpathOne.addAll(pathTwo); // add second path\n\t\treturn pathOne;\n\t}\n\t\n\t/* Search one level and return collision, if any. */\n\tpublic static Person searchLevel(HashMap<Integer, Person> people, BFSData primary, BFSData secondary) {\n\t\t/* We only want to search one level at a time. Count how many nodes are currently in the primary's\n\t\t * level and only do that many nodes. We'll continue to add nodes to the end. */\n\t\tint count = primary.toVisit.size(); \n\t\tfor (int i = 0; i < count; i++) {\n\t\t\t/* Pull out first node. */\n\t\t\tPathNode pathNode = primary.toVisit.poll();\n\t\t\tint personId = pathNode.getPerson().getID();\n\t\t\t\n\t\t\t/* Check if it's already been visited. */\n\t\t\tif (secondary.visited.containsKey(personId)) {\n\t\t\t\treturn pathNode.getPerson();\n\t\t\t}\t\t\t\t\n\t\t\t\n\t\t\t/* Add friends to queue. */\n\t\t\tPerson person = pathNode.getPerson();\n\t\t\tArrayList<Integer> friends = person.getFriends();\n\t\t\tfor (int friendId : friends) {\n\t\t\t\tif (!primary.visited.containsKey(friendId)) {\n\t\t\t\t\tPerson friend = people.get(friendId);\n\t\t\t\t\tPathNode next = new PathNode(friend, pathNode);\n\t\t\t\t\tprimary.visited.put(friendId, next);\n\t\t\t\t\tprimary.toVisit.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static LinkedList<Person> findPathBiBFS(HashMap<Integer, Person> people, int source, int destination) {\n\t\tBFSData sourceData = new BFSData(people.get(source));\n\t\tBFSData destData = new BFSData(people.get(destination));\n\t\t\n\t\twhile (!sourceData.isFinished() && !destData.isFinished()) {\n\t\t\t/* Search out from source. */\n\t\t\tPerson collision = searchLevel(people, sourceData, destData);\n\t\t\tif (collision != null) {\n\t\t\t\treturn mergePaths(sourceData, destData, collision.getID());\n\t\t\t}\n\t\t\t\n\t\t\t/* Search out from destination. */\n\t\t\tcollision = searchLevel(people, destData, sourceData);\n\t\t\tif (collision != null) {\n\t\t\t\treturn mergePaths(sourceData, destData, collision.getID());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\t\n\t\n\tpublic static void main(String[] args) {\n\t\tint nPeople = 11;\n\t\tHashMap<Integer, Person> people = new HashMap<Integer, Person>();\n\t\tfor (int i = 0; i < nPeople; i++) {\n\t\t\tPerson p = new Person(i);\n\t\t\tpeople.put(i, p);\n\t\t}\n\t\t\n\t\tint[][] edges = {{1, 4}, {1, 2}, {1, 3}, {3, 2}, {4, 6}, {3, 7}, {6, 9}, {9, 10}, {5, 10}, {2, 5}, {3, 7}};\n\t\t\n\t\tfor (int[] edge : edges) {\n\t\t\tPerson source = people.get(edge[0]);\n\t\t\tsource.addFriend(edge[1]);\n\t\t\t\n\t\t\tPerson destination = people.get(edge[1]);\n\t\t\tdestination.addFriend(edge[0]);\n\t\t}\n\t\t\n\t\tint i = 1;\n\t\tint j = 10;\n\t\tLinkedList<Person> path1 = findPathBiBFS(people, i, j);\n\t\tTester.printPeople(path1);\n\t}\n\n}\n","Chapter":"Ch 09. Scalability and Memory Limits"}