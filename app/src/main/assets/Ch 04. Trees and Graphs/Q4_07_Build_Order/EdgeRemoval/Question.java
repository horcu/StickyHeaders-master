{"Id":"3951b98d-54ee-43da-8bab-40ea864a8711","Topic":"Question.java","Question":"","Solution":"package Q4_07_Build_Order.EdgeRemoval;\n\nimport java.util.ArrayList;\n\npublic class Question {\n\n\t/* Build the graph, adding the edge (a, b) if b is dependent on a. \n\t * Assumes a pair is listed in “build order”. The pair (a, b) in \n\t * dependencies indicates that b depends on a and a must be built\n\t * before b. */\n\tpublic static Graph buildGraph(String[] projects, String[][] dependencies) {\n\t\tGraph graph = new Graph();\n\t\tfor (String project : projects) {\n\t\t\tgraph.getOrCreateNode(project);\n\t\t}\n\t\t\n\t\tfor (String[] dependency : dependencies) {\n\t\t\tString first = dependency[0];\n\t\t\tString second = dependency[1];\n\t\t\tgraph.addEdge(first, second);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/* A helper function to insert projects with zero dependencies \n\t * into the order array, starting at index offset. */\n\tpublic static int addNonDependent(Project[] order, ArrayList<Project> projects, int offset) {\n\t\tfor (Project project : projects) {\n\t\t\tif (project.getNumberDependencies() == 0) {\n\t\t\t\torder[offset] = project;\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\treturn offset;\n\t}\n\t\n\tpublic static Project[] orderProjects(ArrayList<Project> projects) {\n\t\tProject[] order = new Project[projects.size()];\n\t\t\n\t\t/* Add “roots” to the build order first.*/\n\t\tint endOfList = addNonDependent(order, projects, 0);\n\t\t\n\t\tint toBeProcessed = 0;\n\t\twhile (toBeProcessed < order.length) {\n\t\t\tProject current = order[toBeProcessed];\n\t\t\t\n\t\t\t/* We have a circular dependency since there are no remaining\n\t\t\t * projects with zero dependencies. */ \n\t\t\tif (current == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\t/* Remove myself as a dependency. */\n\t\t\tArrayList<Project> children = current.getChildren();\n\t\t\tfor (Project child : children) {\n\t\t\t\tchild.decrementDependencies();\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\t/* Add children that have no one depending on them. */\n\t\t\tendOfList = addNonDependent(order, children, endOfList);\n\t\t\t\n\t\t\ttoBeProcessed++;\n\t\t}\n\t\t\n\t\treturn order;\n\t}\n\t\n\tpublic static String[] convertToStringList(Project[] projects) {\n\t\tString[] buildOrder = new String[projects.length];\n\t\tfor (int i = 0; i < projects.length; i++) {\n\t\t\tbuildOrder[i] = projects[i].getName();\n\t\t}\n\t\treturn buildOrder;\n\t}\n\t\n\tpublic static Project[] findBuildOrder(String[] projects, String[][] dependencies) {\n\t\tGraph graph = buildGraph(projects, dependencies);\n\t\treturn orderProjects(graph.getNodes());\n\t}\n\t\n\t\n\tpublic static String[] buildOrderWrapper(String[] projects, String[][] dependencies) {\n\t\tProject[] buildOrder = findBuildOrder(projects, dependencies);\n\t\tif (buildOrder == null) return null;\n\t\tString[] buildOrderString = convertToStringList(buildOrder);\n\t\treturn buildOrderString;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tString[] projects = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"};\n\t\tString[][] dependencies = {\n\t\t\t\t{\"a\", \"b\"},\n\t\t\t\t{\"b\", \"c\"},\n\t\t\t\t{\"a\", \"c\"},\n\t\t\t\t{\"a\", \"c\"},\n\t\t\t\t{\"d\", \"e\"},\n\t\t\t\t{\"b\", \"d\"},\n\t\t\t\t{\"e\", \"f\"},\n\t\t\t\t{\"a\", \"f\"},\n\t\t\t\t{\"h\", \"i\"},\n\t\t\t\t{\"h\", \"j\"},\n\t\t\t\t{\"i\", \"j\"},\n\t\t\t\t{\"g\", \"j\"}};\n\t\tString[] buildOrder = buildOrderWrapper(projects, dependencies);\n\t\tif (buildOrder == null) {\n\t\t\tSystem.out.println(\"Circular Dependency.\");\n\t\t} else {\n\t\t\tfor (String s : buildOrder) {\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\t\t}\n\t}\n\n}\n","Chapter":"EdgeRemoval"}