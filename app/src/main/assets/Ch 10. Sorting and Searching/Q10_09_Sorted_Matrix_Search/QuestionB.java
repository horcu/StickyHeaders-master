{"Id":"efb9eb48-29f3-44ea-86c8-82c10394eef1","Topic":"QuestionB.java","Question":"","Solution":"package Q10_09_Sorted_Matrix_Search;\r\nimport CtCILibrary.*;\r\n\r\npublic class QuestionB {\r\n\t\r\n\tpublic static Coordinate partitionAndSearch(int[][] matrix, Coordinate origin, Coordinate dest, Coordinate pivot, int x) {\r\n\t\tCoordinate lowerLeftOrigin = new Coordinate(pivot.row, origin.column);\r\n\t\tCoordinate lowerLeftDest = new Coordinate(dest.row, pivot.column - 1);\r\n\t\tCoordinate upperRightOrigin = new Coordinate(origin.row, pivot.column);\r\n\t\tCoordinate upperRightDest = new Coordinate(pivot.row - 1, dest.column);\r\n\t\t\r\n\t\tCoordinate lowerLeft = findElement(matrix, lowerLeftOrigin, lowerLeftDest, x);\r\n\t\tif (lowerLeft == null) {\r\n\t\t\treturn findElement(matrix, upperRightOrigin, upperRightDest, x);\r\n\t\t}\r\n\t\treturn lowerLeft;\r\n\t}\r\n\t\r\n\tpublic static Coordinate findElement(int[][] matrix, Coordinate origin, Coordinate dest, int x) {\r\n\t\tif (!origin.inbounds(matrix) || !dest.inbounds(matrix)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (matrix[origin.row][origin.column] == x) {\r\n\t\t\treturn origin;\r\n\t\t} else if (!origin.isBefore(dest)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\t/* Set start to start of diagonal and end to the end of the diagonal. Since\r\n\t\t * the grid may not be square, the end of the diagonal may not equal dest.\r\n\t\t */\r\n\t\tCoordinate start = (Coordinate) origin.clone();\r\n\t\tint diagDist = Math.min(dest.row - origin.row, dest.column - origin.column);\r\n\t\tCoordinate end = new Coordinate(start.row + diagDist, start.column + diagDist);\r\n\t\tCoordinate p = new Coordinate(0, 0);\r\n\t\t\r\n\t\t/* Do binary search on the diagonal, looking for the first element greater than x */\r\n\t\twhile (start.isBefore(end)) {\r\n\t\t\tp.setToAverage(start, end);\r\n\t\t\tif (x > matrix[p.row][p.column]) {\r\n\t\t\t\tstart.row = p.row + 1;\r\n\t\t\t\tstart.column = p.column + 1;\r\n\t\t\t} else {\r\n\t\t\t\tend.row = p.row - 1;\r\n\t\t\t\tend.column = p.column - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t/* Split the grid into quadrants. Search the bottom left and the top right. */ \r\n\t\treturn partitionAndSearch(matrix, origin, dest, start, x);\r\n\t}\r\n\t\r\n\tpublic static Coordinate findElement(int[][] matrix, int x) {\r\n\t\tCoordinate origin = new Coordinate(0, 0);\r\n\t\tCoordinate dest = new Coordinate(matrix.length - 1, matrix[0].length - 1);\r\n\t\treturn findElement(matrix, origin, dest, x);\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tint[][] matrix = {{15, 30,  50,  70,  73}, \r\n\t\t\t\t \t \t  {35, 40, 100, 102, 120},\r\n\t\t\t\t \t \t  {36, 42, 105, 110, 125},\r\n\t\t\t\t \t \t  {46, 51, 106, 111, 130},\r\n\t\t\t\t \t \t  {48, 55, 109, 140, 150}};\r\n\t\r\n\t\tAssortedMethods.printMatrix(matrix);\r\n\t\tint m = matrix.length;\r\n\t\tint n = matrix[0].length;\r\n\t\t\r\n\t\tint count = 0;\r\n\t\tint littleOverTheMax = matrix[m - 1][n - 1] + 10;\r\n\t\tfor (int i = 0; i < littleOverTheMax; i++) {\r\n\t\t\tCoordinate c = findElement(matrix, i);\r\n\t\t\tif (c != null) {\r\n\t\t\t\tSystem.out.println(i + \": (\" + c.row + \", \" + c.column + \")\");\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println(\"Found \" + count + \" unique elements.\");\r\n\t}\r\n\r\n}\r\n","Chapter":"Q10_09_Sorted_Matrix_Search"}